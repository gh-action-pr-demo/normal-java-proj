name: Dependency Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

permissions:
  contents: read
  pull-requests: write
  security-events: read

jobs:
  dependency-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Dependency Review
        id: dep-review
        continue-on-error: true
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high

      - name: Get dependency review results and post comment
        id: get-results
        if: steps.dep-review.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            let commentBody = '';
            let hasVulns = false;
            
            try {
              console.log('æ£€æµ‹åˆ°æ¼æ´ï¼Œå¼€å§‹è·å–è¯¦ç»†çš„æ¼æ´ä¿¡æ¯...');
              console.log(`Head SHA: ${context.payload.pull_request.head.sha}`);
              
              let allVulnerabilities = [];
              let dependencyChanges = [];
              
              // ä½¿ç”¨ GitHub Dependency Graph API è·å–å½“å‰ head commit çš„æ‰€æœ‰æ¼æ´
              try {
                // è·å– head commit ä¿¡æ¯
                const { data: headCommit } = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: context.payload.pull_request.head.sha
                });
                
                console.log(`Head commit æœ‰ ${headCommit.parents.length} ä¸ªçˆ¶ commit`);
                
                // æ–¹æ³•1: è·å– base åˆ° head çš„å®Œæ•´å¯¹æ¯”ï¼Œè·å–æ‰€æœ‰æ¼æ´
                const { data: prDiff } = await github.rest.dependencyGraph.diffRange({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  basehead: `${context.payload.pull_request.base.sha}...${context.payload.pull_request.head.sha}`
                });
                
                console.log(`PR diff è¿”å›çš„æ¼æ´æ•°é‡: ${(prDiff.vulnerabilities || []).length}`);
                console.log(`PR diff è¿”å›çš„å˜æ›´æ•°é‡: ${(prDiff.changes || []).length}`);
                
                allVulnerabilities = prDiff.vulnerabilities || [];
                dependencyChanges = prDiff.changes || [];
                
                // æ–¹æ³•2: å¦‚æœ PR diff æ²¡æœ‰è¿”å›æ¼æ´ï¼Œå°è¯•è·å– head commit ç›¸å¯¹äºå…¶çˆ¶ commit çš„æ¼æ´
                // è¿™æ ·å¯ä»¥è·å– head commit ä¸­æ‰€æœ‰å­˜åœ¨çš„æ¼æ´ï¼ˆä¸ä»…ä»…æ˜¯æ–°å¢çš„ï¼‰
                if (allVulnerabilities.length === 0 && headCommit.parents && headCommit.parents.length > 0) {
                  console.log('PR diff æœªè¿”å›æ¼æ´ï¼Œå°è¯•è·å– head commit ç›¸å¯¹äºçˆ¶ commit çš„æ¼æ´...');
                  const parentSha = headCommit.parents[0].sha;
                  const { data: headDiff } = await github.rest.dependencyGraph.diffRange({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    basehead: `${parentSha}...${context.payload.pull_request.head.sha}`
                  });
                  
                  allVulnerabilities = headDiff.vulnerabilities || [];
                  dependencyChanges = headDiff.changes || [];
                  console.log(`Head diff è¿”å›çš„æ¼æ´æ•°é‡: ${allVulnerabilities.length}`);
                }
                
                // æ–¹æ³•3: å¦‚æœè¿˜æ˜¯æ²¡æœ‰æ¼æ´ï¼Œå°è¯•è·å– base commit çš„æ¼æ´ï¼ˆå·²å­˜åœ¨çš„æ¼æ´ï¼‰
                if (allVulnerabilities.length === 0 && headCommit.parents && headCommit.parents.length > 0) {
                  console.log('å°è¯•è·å– base commit çš„æ¼æ´ï¼ˆå·²å­˜åœ¨çš„æ¼æ´ï¼‰...');
                  const parentSha = headCommit.parents[0].sha;
                  
                  // è·å– base commit çš„çˆ¶ commit
                  try {
                    const { data: baseCommit } = await github.rest.repos.getCommit({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: context.payload.pull_request.base.sha
                    });
                    
                    if (baseCommit.parents && baseCommit.parents.length > 0) {
                      const baseParentSha = baseCommit.parents[0].sha;
                      const { data: baseDiff } = await github.rest.dependencyGraph.diffRange({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        basehead: `${baseParentSha}...${context.payload.pull_request.base.sha}`
                      });
                      
                      allVulnerabilities = baseDiff.vulnerabilities || [];
                      dependencyChanges = baseDiff.changes || [];
                      console.log(`Base diff è¿”å›çš„æ¼æ´æ•°é‡: ${allVulnerabilities.length}`);
                    }
                  } catch (baseError) {
                    console.log('æ— æ³•è·å– base commit çš„æ¼æ´:', baseError.message);
                  }
                }
                
              } catch (apiError) {
                console.error('Dependency Graph API è°ƒç”¨å¤±è´¥:', apiError);
                console.error('é”™è¯¯è¯¦æƒ…:', apiError.message);
                throw apiError;
              }
              
              console.log(`æœ€ç»ˆè·å–åˆ°çš„æ¼æ´æ•°é‡: ${allVulnerabilities.length}`);
              console.log(`ä¾èµ–å˜æ›´æ•°é‡: ${dependencyChanges.length}`);
              
              // ç»Ÿè®¡æ¼æ´åŒ…ï¼ˆå»é‡ï¼‰
              const vulnerablePackages = new Set();
              allVulnerabilities.forEach(vuln => {
                vulnerablePackages.add(`${vuln.package.name}@${vuln.package.version}`);
              });

              const hasVulns = allVulnerabilities.length > 0;
              
              // è·å–ä¾èµ–å˜æ›´å’Œè®¸å¯è¯ä¿¡æ¯
              const changes = dependencyChanges || [];
              
              // ç»Ÿè®¡è®¸å¯è¯é—®é¢˜
              let incompatibleLicenses = 0;
              let invalidSpdxLicenses = 0;
              let unknownLicenses = 0;
              const licenseDetails = [];
              
              changes.forEach(change => {
                if (change.change_type === 'added') {
                  // æ£€æŸ¥è®¸å¯è¯ä¿¡æ¯
                  if (change.license) {
                    if (change.license === 'UNKNOWN' || !change.license) {
                      unknownLicenses++;
                      licenseDetails.push({
                        name: change.name,
                        version: change.version,
                        manifest: change.manifest,
                        license: change.license || 'UNKNOWN',
                        type: 'unknown'
                      });
                    }
                  } else {
                    unknownLicenses++;
                    licenseDetails.push({
                      name: change.name,
                      version: change.version,
                      manifest: change.manifest,
                      license: 'UNKNOWN',
                      type: 'unknown'
                    });
                  }
                }
              });

              // æ ¼å¼åŒ–æŠ¥å‘Š
              let commentBody = `## Dependency Review\n\n`;
              commentBody += `**Commit**: \`${context.payload.pull_request.head.sha.substring(0, 7)}\`\n`;
              commentBody += `**æ£€æŸ¥æ—¶é—´**: ${new Date().toISOString()}\n\n`;
              
              commentBody += `The following issues were found:\n\n`;
              
              // æ¼æ´ç»Ÿè®¡
              if (vulnerablePackages.size > 0) {
                commentBody += `âŒ ${vulnerablePackages.size} vulnerable package(s)\n`;
              } else {
                commentBody += `âœ… 0 vulnerable package(s)\n`;
              }
              
              // è®¸å¯è¯ç»Ÿè®¡
              if (incompatibleLicenses > 0) {
                commentBody += `âŒ ${incompatibleLicenses} package(s) with incompatible licenses\n`;
              } else {
                commentBody += `âœ… 0 package(s) with incompatible licenses\n`;
              }
              
              if (invalidSpdxLicenses > 0) {
                commentBody += `âŒ ${invalidSpdxLicenses} package(s) with invalid SPDX license definitions\n`;
              } else {
                commentBody += `âœ… 0 package(s) with invalid SPDX license definitions\n`;
              }
              
              if (unknownLicenses > 0) {
                commentBody += `âš ï¸ ${unknownLicenses} package(s) with unknown licenses.\n`;
              } else {
                commentBody += `âœ… 0 package(s) with unknown licenses.\n`;
              }

              // æ˜¾ç¤ºè¯¦ç»†æ¼æ´åˆ—è¡¨
              if (hasVulns) {
                commentBody += `\n### Vulnerable Packages\n\n`;
                
                // æŒ‰åŒ…åˆ†ç»„æ¼æ´
                const vulnByPackage = {};
                allVulnerabilities.forEach(vuln => {
                  const pkgKey = `${vuln.package.name}@${vuln.package.version}`;
                  if (!vulnByPackage[pkgKey]) {
                    vulnByPackage[pkgKey] = {
                      name: vuln.package.name,
                      version: vuln.package.version,
                      ecosystem: vuln.package.ecosystem || 'maven',
                      vulnerabilities: []
                    };
                  }
                  vulnByPackage[pkgKey].vulnerabilities.push(vuln);
                });

                Object.values(vulnByPackage).forEach((pkg, index) => {
                  commentBody += `${index + 1}. **${pkg.name}@${pkg.version}**\n`;
                  commentBody += `   - **Ecosystem**: ${pkg.ecosystem}\n`;
                  commentBody += `   - **Vulnerabilities**: ${pkg.vulnerabilities.length}\n\n`;
                  
                  pkg.vulnerabilities.forEach((vuln, vulnIndex) => {
                    const severityEmoji = vuln.severity === 'critical' ? 'ğŸ”´' : vuln.severity === 'high' ? 'ğŸŸ ' : vuln.severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                    commentBody += `   ${vulnIndex + 1}. ${severityEmoji} **${vuln.severity || 'unknown'}** severity\n`;
                    
                    if (vuln.advisory) {
                      const advisoryId = vuln.advisory.ghsa_id || vuln.advisory.cve_id || 'N/A';
                      commentBody += `      - **Advisory**: ${advisoryId}\n`;
                      if (vuln.advisory.summary) {
                        commentBody += `      - **Summary**: ${vuln.advisory.summary}\n`;
                      }
                      if (vuln.advisory.cvss?.score) {
                        commentBody += `      - **CVSS Score**: ${vuln.advisory.cvss.score}\n`;
                      }
                    }
                    
                    if (vuln.first_patched_version) {
                      const patchedVersion = vuln.first_patched_version.identifier || vuln.first_patched_version;
                      commentBody += `      - **Patched Version**: ${patchedVersion}\n`;
                    }
                    
                    commentBody += `\n`;
                  });
                });
              }

              // æ˜¾ç¤ºè®¸å¯è¯è¯¦æƒ…
              if (licenseDetails.length > 0) {
                commentBody += `\n### Packages with Unknown Licenses\n\n`;
                licenseDetails.forEach((pkg, index) => {
                  commentBody += `${index + 1}. **${pkg.name}@${pkg.version}**\n`;
                  commentBody += `   - **Manifest**: ${pkg.manifest}\n`;
                  commentBody += `   - **License**: ${pkg.license}\n\n`;
                });
              }

              // æ˜¾ç¤ºä¾èµ–å˜æ›´æ‘˜è¦
              if (changes.length > 0) {
                commentBody += `\n### Dependency Changes\n\n`;
                const added = changes.filter(c => c.change_type === 'added').length;
                const removed = changes.filter(c => c.change_type === 'removed').length;
                const updated = changes.filter(c => c.change_type === 'updated').length;
                
                if (added > 0) commentBody += `â• Added: ${added}\n`;
                if (removed > 0) commentBody += `â– Removed: ${removed}\n`;
                if (updated > 0) commentBody += `ğŸ”„ Updated: ${updated}\n`;
                
                commentBody += `\n<details>\n<summary>View all changes</summary>\n\n`;
                changes.forEach(change => {
                  const changeTypeEmoji = change.change_type === 'added' ? 'â•' : change.change_type === 'removed' ? 'â–' : 'ğŸ”„';
                  commentBody += `${changeTypeEmoji} **${change.manifest}**: ${change.name}@${change.version}\n`;
                });
                commentBody += `\n</details>\n`;
              }

              commentBody += `\n---\n`;
              commentBody += `*æ­¤æŠ¥å‘Šç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆï¼Œæ¯æ¬¡æäº¤éƒ½ä¼šæ›´æ–°*\n`;

              // ç¡®ä¿ commentBody ä¸ä¸ºç©º
              if (!commentBody || commentBody.trim().length === 0) {
                commentBody = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\nâš ï¸ **æ— æ³•ç”ŸæˆæŠ¥å‘Šå†…å®¹**\n\nè¯·æŸ¥çœ‹ GitHub Actions æ—¥å¿—è·å–æ›´å¤šä¿¡æ¯ã€‚\n\n---\n*æ­¤æŠ¥å‘Šç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ*\n`;
              }

              console.log('å‡†å¤‡åˆ›å»ºæ–°è¯„è®º...');
              console.log(`è¯„è®ºå†…å®¹é•¿åº¦: ${commentBody.length} å­—ç¬¦`);
              console.log(`è¯„è®ºå†…å®¹é¢„è§ˆ: ${commentBody.substring(0, 200)}...`);

              // æ¯æ¬¡éƒ½åˆ›å»ºæ–°è¯„è®ºï¼Œä¸æ›´æ–°ç°æœ‰è¯„è®º
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: commentBody
                });
                console.log('æ–°è¯„è®ºåˆ›å»ºæˆåŠŸ');
              } catch (createError) {
                console.error('åˆ›å»ºè¯„è®ºå¤±è´¥:', createError);
                throw createError;
              }

              core.setOutput('has-vulnerabilities', hasVulns ? 'true' : 'false');
              console.log(`è®¾ç½®è¾“å‡º: has-vulnerabilities=${hasVulns}`);
              console.log('è„šæœ¬æ‰§è¡Œå®Œæˆ');
            } catch (error) {
              console.error('è·å–ä¾èµ–å®¡æŸ¥ä¿¡æ¯æ—¶å‡ºé”™:', error);
              console.error('é”™è¯¯å †æ ˆ:', error.stack);
              
              // å¦‚æœ API è°ƒç”¨å¤±è´¥ï¼Œè‡³å°‘åˆ›å»ºä¸€ä¸ªåŸºæœ¬è¯„è®º
              const errorComment = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\nâš ï¸ **æ— æ³•è·å–ä¾èµ–å®¡æŸ¥è¯¦æƒ…**\n\n**é”™è¯¯ä¿¡æ¯**: \`${error.message}\`\n\n**é”™è¯¯ç±»å‹**: ${error.name}\n\nè¯·æŸ¥çœ‹ GitHub Actions æ—¥å¿—è·å–æ›´å¤šä¿¡æ¯ã€‚\n\n---\n*æ­¤æŠ¥å‘Šç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ*\n`;
              
              try {
                // åˆ›å»ºæ–°è¯„è®ºï¼ˆä¸æ›´æ–°ç°æœ‰è¯„è®ºï¼‰
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: errorComment
                });
                console.log('é”™è¯¯è¯„è®ºåˆ›å»ºæˆåŠŸ');
              } catch (commentError) {
                console.error('åˆ›å»ºé”™è¯¯è¯„è®ºæ—¶ä¹Ÿå¤±è´¥äº†:', commentError);
                // å¦‚æœè¿è¯„è®ºéƒ½åˆ›å»ºä¸äº†ï¼Œè‡³å°‘è¾“å‡ºåˆ°æ—¥å¿—
                core.setFailed(`æ— æ³•åˆ›å»ºè¯„è®º: ${commentError.message}`);
              }
              
              core.setOutput('has-vulnerabilities', 'false');
            }

      - name: Fail if vulnerabilities found
        if: steps.dep-review.outcome == 'failure'
        run: |
          echo "å‘ç°å®‰å…¨æ¼æ´ï¼Œè¯·æŸ¥çœ‹ PR è¯„è®ºä¸­çš„è¯¦ç»†æŠ¥å‘Š"
          exit 1
