name: Dependency Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

permissions:
  contents: read
  pull-requests: write
  security-events: read

jobs:
  dependency-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Dependency Review
        id: dep-review
        continue-on-error: true
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high

      - name: Get dependency review results and post comment
        id: get-results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: diffRange } = await github.rest.dependencyGraph.diffRange({
                owner: context.repo.owner,
                repo: context.repo.repo,
                basehead: `${context.payload.pull_request.base.sha}...${context.payload.pull_request.head.sha}`
              });

              let commentBody = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\n`;
              commentBody += `**æ£€æŸ¥æ—¶é—´**: ${new Date().toISOString()}\n`;
              commentBody += `**Commit**: \`${context.payload.pull_request.head.sha.substring(0, 7)}\`\n\n`;

              const vulnerabilities = diffRange.vulnerabilities || [];
              const hasVulns = vulnerabilities.length > 0;

              if (diffRange.change_type === 'removed') {
                commentBody += `âœ… **æ— ä¾èµ–å˜æ›´** - æœ¬æ¬¡æäº¤æœªä¿®æ”¹ä¾èµ–é¡¹\n`;
              } else {
                if (vulnerabilities.length === 0) {
                  commentBody += `âœ… **æœªå‘ç°å®‰å…¨æ¼æ´**\n\n`;
                  commentBody += `æœ¬æ¬¡ä¾èµ–å˜æ›´æœªå¼•å…¥å·²çŸ¥çš„å®‰å…¨æ¼æ´ã€‚\n`;
                } else {
                  commentBody += `âš ï¸ **å‘ç° ${vulnerabilities.length} ä¸ªå®‰å…¨æ¼æ´**\n\n`;
                  
                  const severityCounts = {};
                  vulnerabilities.forEach(vuln => {
                    const severity = vuln.severity || 'unknown';
                    severityCounts[severity] = (severityCounts[severity] || 0) + 1;
                  });

                  commentBody += `### æ¼æ´ç»Ÿè®¡\n`;
                  Object.entries(severityCounts).forEach(([severity, count]) => {
                    const emoji = severity === 'critical' ? 'ğŸ”´' : severity === 'high' ? 'ğŸŸ ' : severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                    commentBody += `- ${emoji} **${severity.toUpperCase()}**: ${count} ä¸ª\n`;
                  });

                  commentBody += `\n### è¯¦ç»†æ¼æ´åˆ—è¡¨\n\n`;
                  vulnerabilities.forEach((vuln, index) => {
                    const severityEmoji = vuln.severity === 'critical' ? 'ğŸ”´' : vuln.severity === 'high' ? 'ğŸŸ ' : vuln.severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                    commentBody += `${index + 1}. ${severityEmoji} **${vuln.package.name}@${vuln.package.version}**\n`;
                    commentBody += `   - **ä¸¥é‡ç¨‹åº¦**: ${vuln.severity || 'unknown'}\n`;
                    if (vuln.advisory) {
                      commentBody += `   - **CVE**: ${vuln.advisory.ghsa_id || vuln.advisory.cve_id || 'N/A'}\n`;
                      commentBody += `   - **æ‘˜è¦**: ${vuln.advisory.summary || 'N/A'}\n`;
                      if (vuln.advisory.cvss?.score) {
                        commentBody += `   - **CVSS åˆ†æ•°**: ${vuln.advisory.cvss.score}\n`;
                      }
                    }
                    if (vuln.first_patched_version) {
                      commentBody += `   - **å»ºè®®å‡çº§è‡³**: ${vuln.first_patched_version.identifier || vuln.first_patched_version}\n`;
                    }
                    commentBody += `\n`;
                  });
                }

                // æ˜¾ç¤ºä¾èµ–å˜æ›´
                const changes = diffRange.changes || [];
                if (changes.length > 0) {
                  commentBody += `\n### ä¾èµ–å˜æ›´\n\n`;
                  changes.forEach(change => {
                    const changeType = change.change_type === 'added' ? 'â•' : change.change_type === 'removed' ? 'â–' : 'ğŸ”„';
                    commentBody += `${changeType} **${change.manifest}**: ${change.name}@${change.version}\n`;
                  });
                }
              }

              commentBody += `\n---\n`;
              commentBody += `*æ­¤æŠ¥å‘Šç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆï¼Œæ¯æ¬¡æäº¤éƒ½ä¼šæ›´æ–°*\n`;

              // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰è¯„è®º
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
              });

              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š')
              );

              if (botComment) {
                // æ›´æ–°ç°æœ‰è¯„è®º
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
              } else {
                // åˆ›å»ºæ–°è¯„è®º
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: commentBody
                });
              }

              core.setOutput('has-vulnerabilities', hasVulns ? 'true' : 'false');
            } catch (error) {
              console.error('Error getting dependency review:', error);
              // å¦‚æœ API è°ƒç”¨å¤±è´¥ï¼Œè‡³å°‘åˆ›å»ºä¸€ä¸ªåŸºæœ¬è¯„è®º
              const errorComment = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\nâš ï¸ **æ— æ³•è·å–ä¾èµ–å®¡æŸ¥è¯¦æƒ…**\n\né”™è¯¯ä¿¡æ¯: ${error.message}\n\nè¯·æŸ¥çœ‹ GitHub Actions æ—¥å¿—è·å–æ›´å¤šä¿¡æ¯ã€‚`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: errorComment
              });
              core.setOutput('has-vulnerabilities', 'false');
            }

      - name: Fail if vulnerabilities found
        if: steps.dep-review.outcome == 'failure' || steps.get-results.outputs.has-vulnerabilities == 'true'
        run: |
          echo "å‘ç°å®‰å…¨æ¼æ´ï¼Œè¯·æŸ¥çœ‹ PR è¯„è®ºä¸­çš„è¯¦ç»†æŠ¥å‘Š"
          exit 1
