name: Dependency Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

permissions:
  contents: read
  pull-requests: write
  security-events: read

jobs:
  dependency-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Dependency Review
        id: dep-review
        continue-on-error: true
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high

      - name: Get dependency review results and post comment
        id: get-results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            let commentBody = '';
            let hasVulns = false;
            
            try {
              console.log('å¼€å§‹è·å–ä¾èµ–å®¡æŸ¥ä¿¡æ¯...');
              console.log(`Base SHA: ${context.payload.pull_request.base.sha}`);
              console.log(`Head SHA: ${context.payload.pull_request.head.sha}`);
              
              // è·å– PR çš„ä¾èµ–å˜æ›´å’Œæ–°å¢æ¼æ´
              const { data: diffRange } = await github.rest.dependencyGraph.diffRange({
                owner: context.repo.owner,
                repo: context.repo.repo,
                basehead: `${context.payload.pull_request.base.sha}...${context.payload.pull_request.head.sha}`
              });
              
              console.log('æˆåŠŸè·å– diffRange æ•°æ®');
              console.log(`Change type: ${diffRange.change_type}`);
              console.log(`Vulnerabilities count: ${(diffRange.vulnerabilities || []).length}`);

              // è·å–æ–°å¢çš„æ¼æ´ï¼ˆPR å¼•å…¥çš„ï¼‰
              const newVulnerabilities = diffRange.vulnerabilities || [];
              
              // è·å– head åˆ†æ”¯çš„æ‰€æœ‰æ¼æ´ï¼ˆåŒ…æ‹¬æ–°å¢å’Œå·²å­˜åœ¨çš„ï¼‰
              // é€šè¿‡æ¯”è¾ƒ head å’Œ head çš„çˆ¶ commit æ¥è·å– head çš„æ‰€æœ‰æ¼æ´
              let allHeadVulnerabilities = [];
              try {
                const { data: headCommit } = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: context.payload.pull_request.head.sha
                });
                
                if (headCommit.parents && headCommit.parents.length > 0) {
                  const parentSha = headCommit.parents[0].sha;
                  const { data: headDiff } = await github.rest.dependencyGraph.diffRange({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    basehead: `${parentSha}...${context.payload.pull_request.head.sha}`
                  });
                  allHeadVulnerabilities = headDiff.vulnerabilities || [];
                }
              } catch (e) {
                console.log('æ— æ³•è·å– head åˆ†æ”¯å®Œæ•´æ¼æ´ä¿¡æ¯:', e.message);
                // å¦‚æœæ— æ³•è·å–ï¼Œå°è¯•ä½¿ç”¨ base åˆ†æ”¯çš„æ¼æ´ä½œä¸ºå‚è€ƒ
                try {
                  const { data: baseCommit } = await github.rest.repos.getCommit({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: context.payload.pull_request.base.sha
                  });
                  
                  if (baseCommit.parents && baseCommit.parents.length > 0) {
                    const parentSha = baseCommit.parents[0].sha;
                    const { data: baseDiff } = await github.rest.dependencyGraph.diffRange({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      basehead: `${parentSha}...${context.payload.pull_request.base.sha}`
                    });
                    allHeadVulnerabilities = baseDiff.vulnerabilities || [];
                  }
                } catch (e2) {
                  console.log('æ— æ³•è·å– base åˆ†æ”¯æ¼æ´ä¿¡æ¯:', e2.message);
                }
              }

              // è®¡ç®—å·²å­˜åœ¨çš„æ¼æ´ = head çš„æ‰€æœ‰æ¼æ´ - æ–°å¢çš„æ¼æ´
              const newVulnKeys = new Set(
                newVulnerabilities.map(v => `${v.package.name}@${v.package.version}:${v.advisory?.ghsa_id || v.advisory?.cve_id || ''}`)
              );
              const existingVulnerabilities = allHeadVulnerabilities.filter(v => {
                const key = `${v.package.name}@${v.package.version}:${v.advisory?.ghsa_id || v.advisory?.cve_id || ''}`;
                return !newVulnKeys.has(key);
              });

              const hasNewVulns = newVulnerabilities.length > 0;
              const hasExistingVulns = existingVulnerabilities.length > 0;
              const hasVulns = hasNewVulns || hasExistingVulns;

              let commentBody = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\n`;
              commentBody += `**æ£€æŸ¥æ—¶é—´**: ${new Date().toISOString()}\n`;
              commentBody += `**Commit**: \`${context.payload.pull_request.head.sha.substring(0, 7)}\`\n\n`;

              // æ˜¾ç¤ºæ–°å¢æ¼æ´
              if (hasNewVulns) {
                commentBody += `### âš ï¸ æœ¬æ¬¡ PR å¼•å…¥çš„æ¼æ´ (${newVulnerabilities.length} ä¸ª)\n\n`;
                
                const newSeverityCounts = {};
                newVulnerabilities.forEach(vuln => {
                  const severity = vuln.severity || 'unknown';
                  newSeverityCounts[severity] = (newSeverityCounts[severity] || 0) + 1;
                });

                commentBody += `**æ¼æ´ç»Ÿè®¡**:\n`;
                Object.entries(newSeverityCounts).forEach(([severity, count]) => {
                  const emoji = severity === 'critical' ? 'ğŸ”´' : severity === 'high' ? 'ğŸŸ ' : severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                  commentBody += `- ${emoji} **${severity.toUpperCase()}**: ${count} ä¸ª\n`;
                });

                commentBody += `\n**è¯¦ç»†åˆ—è¡¨**:\n\n`;
                newVulnerabilities.forEach((vuln, index) => {
                  const severityEmoji = vuln.severity === 'critical' ? 'ğŸ”´' : vuln.severity === 'high' ? 'ğŸŸ ' : vuln.severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                  commentBody += `${index + 1}. ${severityEmoji} **${vuln.package.name}@${vuln.package.version}**\n`;
                  commentBody += `   - **ä¸¥é‡ç¨‹åº¦**: ${vuln.severity || 'unknown'}\n`;
                  if (vuln.advisory) {
                    commentBody += `   - **CVE**: ${vuln.advisory.ghsa_id || vuln.advisory.cve_id || 'N/A'}\n`;
                    commentBody += `   - **æ‘˜è¦**: ${vuln.advisory.summary || 'N/A'}\n`;
                    if (vuln.advisory.cvss?.score) {
                      commentBody += `   - **CVSS åˆ†æ•°**: ${vuln.advisory.cvss.score}\n`;
                    }
                  }
                  if (vuln.first_patched_version) {
                    commentBody += `   - **å»ºè®®å‡çº§è‡³**: ${vuln.first_patched_version.identifier || vuln.first_patched_version}\n`;
                  }
                  commentBody += `\n`;
                });
              } else if (diffRange.change_type !== 'removed') {
                commentBody += `âœ… **æœ¬æ¬¡ PR æœªå¼•å…¥æ–°çš„å®‰å…¨æ¼æ´**\n\n`;
              }

              // æ˜¾ç¤ºå·²å­˜åœ¨çš„æ¼æ´
              if (hasExistingVulns) {
                commentBody += `\n### ğŸ“‹ ä»£ç åº“ä¸­å·²å­˜åœ¨çš„æœªä¿®å¤æ¼æ´ (${existingVulnerabilities.length} ä¸ª)\n\n`;
                commentBody += `*è¿™äº›æ¼æ´åœ¨æœ¬æ¬¡ PR ä¹‹å‰å°±å·²å­˜åœ¨ï¼Œå»ºè®®å°½å¿«ä¿®å¤*\n\n`;
                
                const existingSeverityCounts = {};
                existingVulnerabilities.forEach(vuln => {
                  const severity = vuln.severity || 'unknown';
                  existingSeverityCounts[severity] = (existingSeverityCounts[severity] || 0) + 1;
                });

                commentBody += `**æ¼æ´ç»Ÿè®¡**:\n`;
                Object.entries(existingSeverityCounts).forEach(([severity, count]) => {
                  const emoji = severity === 'critical' ? 'ğŸ”´' : severity === 'high' ? 'ğŸŸ ' : severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                  commentBody += `- ${emoji} **${severity.toUpperCase()}**: ${count} ä¸ª\n`;
                });

                commentBody += `\n**è¯¦ç»†åˆ—è¡¨**:\n\n`;
                existingVulnerabilities.forEach((vuln, index) => {
                  const severityEmoji = vuln.severity === 'critical' ? 'ğŸ”´' : vuln.severity === 'high' ? 'ğŸŸ ' : vuln.severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                  commentBody += `${index + 1}. ${severityEmoji} **${vuln.package.name}@${vuln.package.version}**\n`;
                  commentBody += `   - **ä¸¥é‡ç¨‹åº¦**: ${vuln.severity || 'unknown'}\n`;
                  if (vuln.advisory) {
                    commentBody += `   - **CVE**: ${vuln.advisory.ghsa_id || vuln.advisory.cve_id || 'N/A'}\n`;
                    commentBody += `   - **æ‘˜è¦**: ${vuln.advisory.summary || 'N/A'}\n`;
                    if (vuln.advisory.cvss?.score) {
                      commentBody += `   - **CVSS åˆ†æ•°**: ${vuln.advisory.cvss.score}\n`;
                    }
                  }
                  if (vuln.first_patched_version) {
                    commentBody += `   - **å»ºè®®å‡çº§è‡³**: ${vuln.first_patched_version.identifier || vuln.first_patched_version}\n`;
                  }
                  commentBody += `\n`;
                });
              } else if (!hasNewVulns && diffRange.change_type !== 'removed') {
                commentBody += `\nâœ… **ä»£ç åº“ä¸­æœªå‘ç°å·²å­˜åœ¨çš„å®‰å…¨æ¼æ´**\n\n`;
              }

              // æ˜¾ç¤ºä¾èµ–å˜æ›´
              const changes = diffRange.changes || [];
              if (changes.length > 0) {
                commentBody += `\n### ğŸ“¦ ä¾èµ–å˜æ›´\n\n`;
                changes.forEach(change => {
                  const changeType = change.change_type === 'added' ? 'â•' : change.change_type === 'removed' ? 'â–' : 'ğŸ”„';
                  commentBody += `${changeType} **${change.manifest}**: ${change.name}@${change.version}\n`;
                });
              }

              if (diffRange.change_type === 'removed') {
                commentBody = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\n`;
                commentBody += `**æ£€æŸ¥æ—¶é—´**: ${new Date().toISOString()}\n`;
                commentBody += `**Commit**: \`${context.payload.pull_request.head.sha.substring(0, 7)}\`\n\n`;
                commentBody += `âœ… **æ— ä¾èµ–å˜æ›´** - æœ¬æ¬¡æäº¤æœªä¿®æ”¹ä¾èµ–é¡¹\n`;
                
                if (hasExistingVulns) {
                  commentBody += `\n### ğŸ“‹ ä»£ç åº“ä¸­å·²å­˜åœ¨çš„æœªä¿®å¤æ¼æ´ (${existingVulnerabilities.length} ä¸ª)\n\n`;
                  commentBody += `*è¿™äº›æ¼æ´åœ¨æœ¬æ¬¡ PR ä¹‹å‰å°±å·²å­˜åœ¨ï¼Œå»ºè®®å°½å¿«ä¿®å¤*\n\n`;
                  
                  const existingSeverityCounts = {};
                  existingVulnerabilities.forEach(vuln => {
                    const severity = vuln.severity || 'unknown';
                    existingSeverityCounts[severity] = (existingSeverityCounts[severity] || 0) + 1;
                  });

                  commentBody += `**æ¼æ´ç»Ÿè®¡**:\n`;
                  Object.entries(existingSeverityCounts).forEach(([severity, count]) => {
                    const emoji = severity === 'critical' ? 'ğŸ”´' : severity === 'high' ? 'ğŸŸ ' : severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                    commentBody += `- ${emoji} **${severity.toUpperCase()}**: ${count} ä¸ª\n`;
                  });

                  commentBody += `\n**è¯¦ç»†åˆ—è¡¨**:\n\n`;
                  existingVulnerabilities.forEach((vuln, index) => {
                    const severityEmoji = vuln.severity === 'critical' ? 'ğŸ”´' : vuln.severity === 'high' ? 'ğŸŸ ' : vuln.severity === 'moderate' ? 'ğŸŸ¡' : 'âšª';
                    commentBody += `${index + 1}. ${severityEmoji} **${vuln.package.name}@${vuln.package.version}**\n`;
                    commentBody += `   - **ä¸¥é‡ç¨‹åº¦**: ${vuln.severity || 'unknown'}\n`;
                    if (vuln.advisory) {
                      commentBody += `   - **CVE**: ${vuln.advisory.ghsa_id || vuln.advisory.cve_id || 'N/A'}\n`;
                      commentBody += `   - **æ‘˜è¦**: ${vuln.advisory.summary || 'N/A'}\n`;
                      if (vuln.advisory.cvss?.score) {
                        commentBody += `   - **CVSS åˆ†æ•°**: ${vuln.advisory.cvss.score}\n`;
                      }
                    }
                    if (vuln.first_patched_version) {
                      commentBody += `   - **å»ºè®®å‡çº§è‡³**: ${vuln.first_patched_version.identifier || vuln.first_patched_version}\n`;
                    }
                    commentBody += `\n`;
                  });
                } else {
                  commentBody += `\nâœ… **ä»£ç åº“ä¸­æœªå‘ç°å·²å­˜åœ¨çš„å®‰å…¨æ¼æ´**\n\n`;
                }
              }

              commentBody += `\n---\n`;
              commentBody += `*æ­¤æŠ¥å‘Šç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆï¼Œæ¯æ¬¡æäº¤éƒ½ä¼šæ›´æ–°*\n`;

              // ç¡®ä¿ commentBody ä¸ä¸ºç©º
              if (!commentBody || commentBody.trim().length === 0) {
                commentBody = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\nâš ï¸ **æ— æ³•ç”ŸæˆæŠ¥å‘Šå†…å®¹**\n\nè¯·æŸ¥çœ‹ GitHub Actions æ—¥å¿—è·å–æ›´å¤šä¿¡æ¯ã€‚\n\n---\n*æ­¤æŠ¥å‘Šç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ*\n`;
              }

              console.log('å‡†å¤‡åˆ›å»º/æ›´æ–°è¯„è®º...');
              console.log(`è¯„è®ºå†…å®¹é•¿åº¦: ${commentBody.length} å­—ç¬¦`);
              console.log(`è¯„è®ºå†…å®¹é¢„è§ˆ: ${commentBody.substring(0, 200)}...`);

              // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰è¯„è®º
              let comments;
              try {
                const response = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                });
                comments = response.data;
                console.log(`æ‰¾åˆ° ${comments.length} æ¡è¯„è®º`);
              } catch (listError) {
                console.error('è·å–è¯„è®ºåˆ—è¡¨å¤±è´¥:', listError);
                throw listError;
              }

              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š')
              );

              if (botComment) {
                console.log(`æ‰¾åˆ°ç°æœ‰è¯„è®ºï¼ŒID: ${botComment.id}ï¼Œå‡†å¤‡æ›´æ–°`);
                try {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: botComment.id,
                    body: commentBody
                  });
                  console.log('è¯„è®ºæ›´æ–°æˆåŠŸ');
                } catch (updateError) {
                  console.error('æ›´æ–°è¯„è®ºå¤±è´¥:', updateError);
                  throw updateError;
                }
              } else {
                console.log('æœªæ‰¾åˆ°ç°æœ‰è¯„è®ºï¼Œåˆ›å»ºæ–°è¯„è®º');
                try {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.payload.pull_request.number,
                    body: commentBody
                  });
                  console.log('è¯„è®ºåˆ›å»ºæˆåŠŸ');
                } catch (createError) {
                  console.error('åˆ›å»ºè¯„è®ºå¤±è´¥:', createError);
                  throw createError;
                }
              }

              core.setOutput('has-vulnerabilities', hasVulns ? 'true' : 'false');
              console.log(`è®¾ç½®è¾“å‡º: has-vulnerabilities=${hasVulns}`);
              console.log('è„šæœ¬æ‰§è¡Œå®Œæˆ');
            } catch (error) {
              console.error('è·å–ä¾èµ–å®¡æŸ¥ä¿¡æ¯æ—¶å‡ºé”™:', error);
              console.error('é”™è¯¯å †æ ˆ:', error.stack);
              
              // å¦‚æœ API è°ƒç”¨å¤±è´¥ï¼Œè‡³å°‘åˆ›å»ºä¸€ä¸ªåŸºæœ¬è¯„è®º
              const errorComment = `## ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š\n\nâš ï¸ **æ— æ³•è·å–ä¾èµ–å®¡æŸ¥è¯¦æƒ…**\n\n**é”™è¯¯ä¿¡æ¯**: \`${error.message}\`\n\n**é”™è¯¯ç±»å‹**: ${error.name}\n\nè¯·æŸ¥çœ‹ GitHub Actions æ—¥å¿—è·å–æ›´å¤šä¿¡æ¯ã€‚\n\n---\n*æ­¤æŠ¥å‘Šç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ*\n`;
              
              try {
                // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰è¯„è®º
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                });

                const botComment = comments.find(comment => 
                  comment.user.type === 'Bot' && 
                  comment.body.includes('ğŸ” ä¾èµ–å®‰å…¨æ£€æŸ¥æŠ¥å‘Š')
                );

                if (botComment) {
                  await github.rest.issues.updateComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: botComment.id,
                    body: errorComment
                  });
                  console.log('é”™è¯¯è¯„è®ºæ›´æ–°æˆåŠŸ');
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.payload.pull_request.number,
                    body: errorComment
                  });
                  console.log('é”™è¯¯è¯„è®ºåˆ›å»ºæˆåŠŸ');
                }
              } catch (commentError) {
                console.error('åˆ›å»ºé”™è¯¯è¯„è®ºæ—¶ä¹Ÿå¤±è´¥äº†:', commentError);
                // å¦‚æœè¿è¯„è®ºéƒ½åˆ›å»ºä¸äº†ï¼Œè‡³å°‘è¾“å‡ºåˆ°æ—¥å¿—
                core.setFailed(`æ— æ³•åˆ›å»ºè¯„è®º: ${commentError.message}`);
              }
              
              core.setOutput('has-vulnerabilities', 'false');
            }

      - name: Fail if vulnerabilities found
        if: steps.dep-review.outcome == 'failure' || steps.get-results.outputs.has-vulnerabilities == 'true'
        run: |
          echo "å‘ç°å®‰å…¨æ¼æ´ï¼Œè¯·æŸ¥çœ‹ PR è¯„è®ºä¸­çš„è¯¦ç»†æŠ¥å‘Š"
          exit 1
